package org.muzima.turkana.service;

import org.muzima.turkana.model.Registration;
import org.muzima.turkana.model.Sms;
import org.muzima.turkana.utils.CryptoUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Signature;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.util.List;

import static org.muzima.turkana.utils.Constants.SECURITY.MESSAGE_DIGEST_ALGORITHM;
import static org.muzima.turkana.utils.Constants.SECURITY.SIGNATURE_ALGORITHM;

/**
 * @author Samuel Owino
 */

public interface SmsService {
    Logger LOGGER = LoggerFactory.getLogger(SmsService.class);

    Sms saveSms(Sms sms);

    List<Sms> saveAllSms(List<Sms> smsList);

    Sms getSms(Long id);

    List<Sms> getAllSms();

    void updateSms(Sms sms);

    void deleteSms(Long id);

    /**
     * Verifies the sms's body signature. Uses the senders public key to do this.
     * @param sms   whose body is to be verified.
     * @param signature to be verified (obtained by signing the sms body)
     * @param registration the registration instance representing the sender.
     * @return saved Sms.
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeySpecException
     * @throws InvalidKeyException
     * @throws SignatureException
     * @throws MessageVerificationException
     */
    default Sms verifySmsAndSave(final Sms sms, final byte[] signature, final Registration registration)
            throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException, SignatureException, MessageVerificationException {
        Signature rsaSignatureInstance = Signature.getInstance(SIGNATURE_ALGORITHM);
        rsaSignatureInstance.initVerify(CryptoUtils.getPublicKeyFromText(registration.getPublicKey()));

        rsaSignatureInstance.update(sms.getBody().getBytes());

        if(rsaSignatureInstance.verify(signature)) {
            LOGGER.info("Signature verified successfully for sms");
            return saveSms(sms);
        } else {
            LOGGER.error("Signature verification failed, sms not saved");
            throw new MessageVerificationException(sms, signature, registration.getPublicKey());
        }
    }

    /**
     * Verifies multiple sms. The algorithm expects the sender to concatenate all message bodies, calculate a hash, then sign this hash.
     * @param smsList   List of sms to be verified against the signature
     * @param signature The signature generated by the sender.
     * @param registration  registration information associated with the sender.
     * @return  The list of Sms'es saved.
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeySpecException
     * @throws InvalidKeyException
     * @throws SignatureException
     * @throws MessageVerificationException
     */
    default List<Sms> verifyMultipleSmsAndSave(final List<Sms> smsList, final byte[] signature, final Registration registration)
            throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException, SignatureException, MessageVerificationException {
        final StringBuilder builder = new StringBuilder();
        for (Sms sms : smsList) {
            builder.append(sms.getBody());
        }

        MessageDigest messageDigest = MessageDigest.getInstance(MESSAGE_DIGEST_ALGORITHM);
        byte[] hashedConcatenatedMessages = messageDigest.digest(builder.toString().getBytes());

        Signature rsaSignatureInstance = Signature.getInstance(SIGNATURE_ALGORITHM);
        rsaSignatureInstance.initVerify(CryptoUtils.getPublicKeyFromText(registration.getPublicKey()));
        rsaSignatureInstance.update(hashedConcatenatedMessages);

        if(rsaSignatureInstance.verify(signature)) {
            LOGGER.info("Signature verified successfully for sms list");
            return saveAllSms(smsList);
        } else {
            LOGGER.error("Signature verification failed, sms list not saved");
            throw new MessageVerificationException(smsList, signature, registration.getPublicKey());
        }
    }
}
